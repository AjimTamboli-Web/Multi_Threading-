package multi_Threading;

public class C_Implementing_Runnable_Interface {

	public static void main(String[] args) {

/*
 * ⚠️ Defining a Thread by implementing Runnable interface::
 * Runnable interface present in java.lang package, and it contains only one method => public void run();
    we will get mixed output and we can't tell exact output.
  
 * Case study:: 
 * Case1 :: 
    t1.start(); => a new thread will be created which is responsible for the execution of Thread class run(),
      				  which has empty implementation.
      					
 * Case2 :: 
     t1.run(); => no new thread will be created and thread class run() method will be executed just like a 
          			normal method call.
  
 * Case3 ::
    t2.start(); => a new thread will be created which is responsible for the execution of myRunnable class
     				inside run() method.
    
 * Case4 ::
    t2.run(); => a new thread won't be created and myRunnable run() will be executed just like a normal 
  				 method call
  
 * Case5 :: 
    r.start() => we will get compile time error saying myRunnable class does't have start() capability
     			 CE: cannot find symbol , location: class myRunnable
  
 * Case6 ::
   r.run()=>no new thread will be created and my runnable run method will be executed like normal method call
   
 		
 * ⏺️ Which approach is best to define a thread??❓
 *  >> ✔️ Among two ways of define a thread implements runnable approach is recommended.
    1️⃣ in the first approach our class always extends Thread class, there is no chance of extending any other 
       class hence, we are missing inheritance benefits.
    2️⃣ but in the second approach while implementing runnable interface we can extends any other class hence,
       we won't miss any inheritance benefits
 because of above reason implementing runnable interface approach is recommended than extending thread class
  
  
 * Getting and Setting name of a Thread:: 
 *  Every thread in java has a some name it may be default name generated by JVM or customized name provided
   		by programmer.
   	>>  We can get and set name of a thread by using the following two methods of thread class:: 
   	 		public final String getName();
   	 		public final void setName(String name);
 * NOTE::  We can get a current executing thread object by using Thread.currentThread()
 */
		
		System.out.println(Thread.currentThread().getName());
		
		myRunnable r = new myRunnable();
		
		Thread t1 = new Thread();
		Thread t2 = new Thread(r); // r is a target runnable
		
		t1.start();  // case1 empty implementation
		t1.run();    // case2 normal method call
		t2.start();  // case3 new thread created
		t2.run();    // case4 normal method call
//		r.start();   // case5 CE: The method start() is undefined for the type myRunnable
		r.run();     // case6 normal method call
		
		System.out.println("t1 instance: " + t1.getName());  // give you thread name
		
		Thread.currentThread().setName("Baratheon");  // set name for main thread
		System.out.println(Thread.currentThread().getName());
//		System.out.println(10/0); // ArithmeticException 
		
		
		
		
		Prime_Inter pri = new Prime_Inter();
		Thread th1 = new Thread(pri); // pri => is Target Runnable
		th1.start();
		
		// executed by main thread
		int count = 1;
		while(count < 10) {
			System.out.println("Table: " + count*2);
			count++;
		}
		
		// pass lambda instead of using runnable interface
		Thread th2 = new Thread(() -> { // creating a thread using lambda
			
				for(int i =0;i<10;i++) {
					System.out.println(i*5);
				}
			
		});
		
		th2.start();

	}

}

class myRunnable implements Runnable{

	@Override
	public void run() {
		System.out.println("run() from myRunnable class  ");
		
	}
	
}



class Prime_Inter implements Runnable{

	@Override
	public void run() {
		
		for(int i = 2;i<100;i++) {
			boolean flag = false;
			for(int j=2;j<i;j++) {
				if(i%j == 0) {
					flag = true;
				}
			}
			if(flag == false) {
				System.out.println("Prime:: " + i);
			}
		}
		
		
		
	}
	
}


